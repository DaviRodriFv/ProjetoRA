<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, viewport-fit=cover, initial-scale=1.0"
    />
    <title>AR — Objetos Interativos Animados</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #menu {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.55);
        padding: 8px 14px;
        border-radius: 10px;
        z-index: 20;
        color: white;
        font-size: 14px;
      }
      #menu button {
        background: #0b84ff;
        color: white;
        border: none;
        padding: 6px 10px;
        margin: 0 4px;
        border-radius: 6px;
        cursor: pointer;
      }
      #msg {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 8px 12px;
        border-radius: 8px;
        z-index: 20;
        display: none;
      }
    </style>
  </head>

  <body>
    <div id="menu">
      Escolher objeto:
      <button onclick="setObject('tower')">Torre</button>
      <button onclick="setObject('ufo')">OVNIs</button>
      <button onclick="setObject('dragon')">Dragão</button>
    </div>

    <div id="msg"></div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.150.0/build/three.module.js";
      import { GLTFLoader } from "https://unpkg.com/three@0.150.0/examples/jsm/loaders/GLTFLoader.js";
      import { ARButton } from "https://unpkg.com/three@0.150.0/examples/jsm/webxr/ARButton.js";

      let camera, scene, renderer;
      let reticle,
        hitTestSource = null,
        hitRequested = false;
      let currentSelection = "tower";
      let activeObject = null;
      const clock = new THREE.Clock();

      const loader = new GLTFLoader();

      init();
      animate();

      function showMsg(txt, time = 2000) {
        const m = document.getElementById("msg");
        m.textContent = txt;
        m.style.display = "block";
        setTimeout(() => (m.style.display = "none"), time);
      }

      // Trocar objeto e remover o antigo
      window.setObject = async function (name) {
        currentSelection = name;
        showMsg("Selecionado: " + name);

        if (activeObject) {
          scene.remove(activeObject);
          activeObject = null;
        }
      };

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          20
        );
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
        const dl = new THREE.DirectionalLight(0xffffff, 1);
        dl.position.set(1, 1, 1);
        scene.add(dl);

        const ringGeo = new THREE.RingGeometry(0.1, 0.14, 32).rotateX(
          -Math.PI / 2
        );
        reticle = new THREE.Mesh(
          ringGeo,
          new THREE.MeshBasicMaterial({ color: 0x00ff66 })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        const controller = renderer.xr.getController(0);
        controller.addEventListener("select", onSelect);
        scene.add(controller);

        document.body.appendChild(
          ARButton.createButton(renderer, { requiredFeatures: ["hit-test"] })
        );

        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      function loadModel(url, scale = 1) {
        return new Promise((resolve) => {
          loader.load(url, (gltf) => {
            const model = gltf.scene;
            model.scale.setScalar(scale);
            resolve(model);
          });
        });
      }

      async function createObject() {
        if (currentSelection === "tower") {
          const obj = await loadModel(
            "https://models.readyplayer.me/Objects/Tower.glb",
            1
          );
          obj.userData = { type: "tower" };
          return obj;
        }
        if (currentSelection === "ufo") {
          const obj = await loadModel(
            "https://assets.mixkit.co/storage/models/107.glb",
            0.6
          );
          obj.userData = { type: "ufo", floatDir: 1 };
          return obj;
        }
        if (currentSelection === "dragon") {
          const obj = await loadModel(
            "https://threejs.org/examples/models/gltf/DragonAttenuation/glTF/DragonAttenuation.gltf",
            0.7
          );
          obj.userData = { type: "dragon" };
          return obj;
        }
      }

      async function onSelect() {
        if (!reticle.visible) return;

        if (activeObject === null) {
          activeObject = await createObject();
          activeObject.matrix.copy(reticle.matrix);
          activeObject.matrix.decompose(
            activeObject.position,
            activeObject.quaternion,
            activeObject.scale
          );
          scene.add(activeObject);
          showMsg("Objeto colocado!");
        } else {
          activeObject.rotation.y += Math.PI / 4;
          showMsg("Girando objeto...");
        }
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render(t, frame) {
        const dt = clock.getDelta();

        if (activeObject) {
          // Animações diferenciadas por tipo
          if (activeObject.userData.type === "dragon") {
            activeObject.rotation.y += dt * 0.5;
            activeObject.position.y = 0.1 * Math.sin(clock.elapsedTime * 2);
          } else if (activeObject.userData.type === "ufo") {
            activeObject.rotation.y += dt;
            activeObject.position.y += 0.01 * activeObject.userData.floatDir;
            if (activeObject.position.y > 0.15)
              activeObject.userData.floatDir = -1;
            if (activeObject.position.y < 0) activeObject.userData.floatDir = 1;
          } else if (activeObject.userData.type === "tower") {
            activeObject.rotation.y += dt * 0.1;
          }
        }

        const session = renderer.xr.getSession();
        if (session && frame) {
          if (!hitRequested) {
            session.requestReferenceSpace("viewer").then((refSpace) => {
              session
                .requestHitTestSource({ space: refSpace })
                .then((source) => (hitTestSource = source));
            });
            hitRequested = true;
          }

          if (hitTestSource) {
            const refSpace = renderer.xr.getReferenceSpace();
            const results = frame.getHitTestResults(hitTestSource);

            if (results.length > 0) {
              const pose = results[0].getPose(refSpace);
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
