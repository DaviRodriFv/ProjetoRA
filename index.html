<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, viewport-fit=cover, initial-scale=1.0"
    />
    <title>AR â€” Objetos Interativos</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #menu {
        position: fixed;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.55);
        padding: 8px 14px;
        border-radius: 10px;
        z-index: 20;
        color: white;
        font-size: 14px;
      }
      #menu button {
        background: #0b84ff;
        color: white;
        border: none;
        padding: 6px 10px;
        margin: 0 4px;
        border-radius: 6px;
        cursor: pointer;
      }
      #msg {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 8px 12px;
        border-radius: 8px;
        z-index: 20;
        display: none;
      }
    </style>
  </head>

  <body>
    <div id="menu">
      Escolher objeto:
      <button onclick="setObject('cube')">Cubo</button>
      <button onclick="setObject('planet')">Planeta</button>
    </div>

    <div id="msg"></div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.150.0/build/three.module.js";
      import { ARButton } from "https://unpkg.com/three@0.150.0/examples/jsm/webxr/ARButton.js";

      let camera, scene, renderer;
      let reticle,
        hitTestSource = null,
        hitRequested = false;
      let currentSelection = "cube";
      let activeObject = null; // objeto colocado

      const clock = new THREE.Clock();

      init();
      animate();

      function showMsg(txt, time = 2000) {
        const m = document.getElementById("msg");
        m.textContent = txt;
        m.style.display = "block";
        setTimeout(() => (m.style.display = "none"), time);
      }

      window.setObject = function (name) {
        currentSelection = name;
        showMsg("Selecionado: " + name);
      };

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          20
        );

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1));
        const dl = new THREE.DirectionalLight(0xffffff, 0.7);
        dl.position.set(1, 1, 1);
        scene.add(dl);

        // reticle
        const ringGeo = new THREE.RingGeometry(0.1, 0.14, 32).rotateX(
          -Math.PI / 2
        );
        reticle = new THREE.Mesh(
          ringGeo,
          new THREE.MeshBasicMaterial({ color: 0x00ff66 })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        const controller = renderer.xr.getController(0);
        controller.addEventListener("select", onSelect);
        scene.add(controller);

        document.body.appendChild(
          ARButton.createButton(renderer, { requiredFeatures: ["hit-test"] })
        );

        window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }

      // ðŸ“Œ Objetos prÃ©-prontos (super leves)
      function makeCube() {
        const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const mat = new THREE.MeshStandardMaterial({ color: 0x0077ff });
        const cube = new THREE.Mesh(geo, mat);
        cube.userData = { type: "cube", rot: 0 };
        return cube;
      }

      function makePlanet() {
        const geo = new THREE.SphereGeometry(0.3, 32, 32);
        const tex = new THREE.TextureLoader().load(
          "https://upload.wikimedia.org/wikipedia/commons/4/4a/Earth_%28texture%29.png"
        );
        const mat = new THREE.MeshStandardMaterial({ map: tex });
        const sphere = new THREE.Mesh(geo, mat);
        sphere.userData = { type: "planet" };
        return sphere;
      }

      function onSelect() {
        if (reticle.visible) {
          if (activeObject === null) {
            // criar objeto selecionado
            activeObject =
              currentSelection === "cube" ? makeCube() : makePlanet();

            activeObject.visible = true;
            activeObject.matrix.copy(reticle.matrix);
            activeObject.matrix.decompose(
              activeObject.position,
              activeObject.quaternion,
              activeObject.scale
            );

            scene.add(activeObject);
            showMsg("Objeto colocado!");
          } else {
            // interaÃ§Ã£o â€” toques no objeto
            if (activeObject.userData.type === "cube") {
              activeObject.userData.rot += Math.PI / 4;
              showMsg("Cubo girando!");
            } else if (activeObject.userData.type === "planet") {
              showMsg("Planeta continua girando...");
            }
          }
        }
      }

      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render(t, frame) {
        const dt = clock.getDelta();

        // animaÃ§Ãµes
        if (activeObject) {
          if (activeObject.userData.type === "cube") {
            // anima para o alvo
            activeObject.rotation.y +=
              (activeObject.userData.rot - activeObject.rotation.y) * dt * 5;
          } else if (activeObject.userData.type === "planet") {
            activeObject.rotation.y += dt * 0.6;
          }
        }

        // hit test
        const session = renderer.xr.getSession();
        if (session && frame) {
          if (!hitRequested) {
            session.requestReferenceSpace("viewer").then((refSpace) => {
              session
                .requestHitTestSource({ space: refSpace })
                .then((source) => (hitTestSource = source));
            });
            hitRequested = true;
          }

          if (hitTestSource) {
            const refSpace = renderer.xr.getReferenceSpace();
            const results = frame.getHitTestResults(hitTestSource);

            if (results.length > 0) {
              const pose = results[0].getPose(refSpace);
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
