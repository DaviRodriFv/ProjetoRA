<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, viewport-fit=cover, initial-scale=1.0"
    />
    <title>Portão AR — Hit Test (Three.js)</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: Arial, sans-serif;
      }
      #info {
        position: fixed;
        left: 10px;
        top: 10px;
        background: rgba(0, 0, 0, 0.55);
        color: #fff;
        padding: 8px 12px;
        border-radius: 8px;
        z-index: 10;
        max-width: calc(100% - 40px);
      }
      #msg {
        position: fixed;
        left: 50%;
        bottom: 18px;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.65);
        color: #fff;
        padding: 10px 14px;
        border-radius: 10px;
        z-index: 10;
        display: none;
      }
      #enter-ar {
        display: block;
        margin-top: 8px;
        padding: 8px 10px;
        border-radius: 8px;
        background: #0b84ff;
        color: white;
        border: none;
        cursor: pointer;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <div><strong>Portão AR (Three.js — Hit test)</strong></div>
      <div style="margin-top: 6px; font-size: 13px">
        Aponte a câmera para o chão → mova o dispositivo até ver o retículo
        (círculo). Toque na tela para colocar o portão. Depois toque no portão
        para <em>abrir/fechar</em>.
      </div>
      <button id="enter-ar" style="display: none">Entrar em AR</button>
    </div>
    <div id="msg"></div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.150.0/build/three.module.js";
      import { ARButton } from "https://unpkg.com/three@0.150.0/examples/jsm/webxr/ARButton.js";

      let container, camera, scene, renderer;
      let reticle,
        hitTestSource = null,
        hitTestSourceRequested = false;
      let gate = null; // grupo do portão
      const clock = new THREE.Clock();

      init();
      animate();

      function showMessage(text, time = 2500) {
        const el = document.getElementById("msg");
        el.style.display = "block";
        el.textContent = text;
        if (time)
          setTimeout(() => {
            el.style.display = "none";
          }, time);
      }

      function init() {
        container = document.createElement("div");
        document.body.appendChild(container);

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          20
        );

        // renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        container.appendChild(renderer.domElement);

        // lights
        const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        scene.add(light);
        const d = new THREE.DirectionalLight(0xffffff, 0.6);
        d.position.set(0.5, 1, 0.25).normalize();
        scene.add(d);

        // reticle (indica onde o hit test detectou superfície)
        const ringGeo = new THREE.RingGeometry(0.12, 0.16, 32).rotateX(
          -Math.PI / 2
        );
        const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff66 });
        reticle = new THREE.Mesh(ringGeo, ringMat);
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // build gate (but don't add to scene until placed)
        gate = buildGate();
        gate.visible = false;
        scene.add(gate);

        // controller for input (touch)
        const controller = renderer.xr.getController(0);
        controller.addEventListener("select", onSelect);
        scene.add(controller);

        // AR button - create UI to enter AR
        const arButton = ARButton.createButton(renderer, {
          requiredFeatures: ["hit-test"],
        });
        // hide default AR button (we will show our own simpler)
        arButton.style.display = "none";
        document.body.appendChild(arButton);

        // show a custom button that triggers the same action
        const enterBtn = document.getElementById("enter-ar");
        enterBtn.style.display = "block";
        enterBtn.onclick = () => {
          // start session (this triggers permission prompts)
          navigator.xr && navigator.xr.requestSession
            ? renderer.xr.setSession(arButton.onclick && arButton.onclick())
            : showMessage(
                "Seu navegador não suporta WebXR. Use Chrome no Android."
              );
        };

        window.addEventListener("resize", onWindowResize);
      }

      function buildGate() {
        const group = new THREE.Group();

        // posts
        const postGeo = new THREE.BoxGeometry(0.12, 1.2, 0.12);
        const postMat = new THREE.MeshStandardMaterial({
          color: 0x6b4f2b,
          metalness: 0.1,
          roughness: 0.8,
        });
        const leftPost = new THREE.Mesh(postGeo, postMat);
        const rightPost = leftPost.clone();
        leftPost.position.set(-0.85, 0.6, 0);
        rightPost.position.set(0.85, 0.6, 0);
        group.add(leftPost, rightPost);

        // top beam
        const beamGeo = new THREE.BoxGeometry(1.9, 0.12, 0.14);
        const beam = new THREE.Mesh(beamGeo, postMat);
        beam.position.set(0, 1.2 + 0.06, 0);
        group.add(beam);

        // two doors (swing)
        const doorGeo = new THREE.BoxGeometry(0.85, 1.0, 0.06);
        const doorMat = new THREE.MeshStandardMaterial({
          color: 0x333333,
          metalness: 0.6,
          roughness: 0.4,
        });

        // left door pivot
        const leftDoorPivot = new THREE.Group();
        const leftDoor = new THREE.Mesh(doorGeo, doorMat);
        leftDoor.position.set(-0.425, 0.5, 0);
        leftDoorPivot.add(leftDoor);
        leftDoorPivot.position.set(-0.85 + 0.02, 0, 0); // hinge near post
        group.add(leftDoorPivot);

        // right door pivot
        const rightDoorPivot = new THREE.Group();
        const rightDoor = new THREE.Mesh(doorGeo, doorMat);
        rightDoor.position.set(0.425, 0.5, 0);
        rightDoorPivot.add(rightDoor);
        rightDoorPivot.position.set(0.85 - 0.02, 0, 0);
        group.add(rightDoorPivot);

        // store pivots for animation control
        group.userData = {
          leftPivot: leftDoorPivot,
          rightPivot: rightDoorPivot,
          openTarget: 0, // 0 = closed, 1 = open
          openCurrent: 0, // interpolated value
        };

        // a tiny collision invisible box for tapping detection
        const touchGeo = new THREE.BoxGeometry(2.0, 1.6, 0.6);
        const touchMat = new THREE.MeshBasicMaterial({ visible: false });
        const touchBox = new THREE.Mesh(touchGeo, touchMat);
        touchBox.position.set(0, 0.8, 0);
        group.add(touchBox);
        group.userData.touchBox = touchBox;

        return group;
      }

      function onSelect() {
        // if reticle visible and gate not placed -> place gate
        if (reticle.visible && !gate.userData.placed) {
          // apply reticle's matrix to gate
          gate.visible = true;
          gate.userData.placed = true;
          // position
          const matrix = new THREE.Matrix4();
          matrix.copy(reticle.matrix);
          gate.applyMatrix4(matrix);
          // ensure gate upright
          gate.rotation.x = 0;
          gate.rotation.z = 0;
          // small message
          showMessage("Portão colocado! Toque no portão para abrir/fechar.");
          return;
        }

        // else if gate placed -> check if touch hits the gate touchBox (raycast)
        if (gate.userData.placed) {
          // raycast from controller forward
          const controller = renderer.xr.getController(0);
          const tempMatrix = new THREE.Matrix4();
          tempMatrix.identity().extractRotation(controller.matrixWorld);

          const rayOrigin = new THREE.Vector3().setFromMatrixPosition(
            controller.matrixWorld
          );
          const rayDirection = new THREE.Vector3(0, 0, -1)
            .applyMatrix4(tempMatrix)
            .sub(rayOrigin)
            .normalize();
          const raycaster = new THREE.Raycaster(rayOrigin, rayDirection, 0, 10);

          const intersects = raycaster.intersectObject(
            gate.userData.touchBox,
            true
          );
          if (intersects.length > 0) {
            // toggle open / close
            gate.userData.openTarget = gate.userData.openTarget === 0 ? 1 : 0;
            showMessage(
              gate.userData.openTarget === 1 ? "Abrindo..." : "Fechando..."
            );
          }
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // animation loop
      function animate() {
        renderer.setAnimationLoop(render);
      }

      function render(timestamp, frame) {
        const dt = clock.getDelta();

        // handle hit test
        if (frame) {
          const referenceSpace = renderer.xr.getReferenceSpace();
          const session = renderer.xr.getSession();

          if (!hitTestSourceRequested) {
            session.requestReferenceSpace("viewer").then((refSpace) => {
              session
                .requestHitTestSource({ space: refSpace })
                .then((source) => {
                  hitTestSource = source;
                });
            });
            session.addEventListener("end", () => {
              hitTestSourceRequested = false;
              hitTestSource = null;
              reticle.visible = false;
            });
            hitTestSourceRequested = true;
          }

          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const pose = hit.getPose(renderer.xr.getReferenceSpace());
              reticle.visible = true;
              reticle.matrix.fromArray(pose.transform.matrix);
            } else {
              reticle.visible = false;
            }
          }
        }

        // animate gate open/close (interpolate)
        if (gate && gate.userData.placed) {
          // smooth interpolation
          const s = 6.0; // speed
          gate.userData.openCurrent +=
            (gate.userData.openTarget - gate.userData.openCurrent) *
            Math.min(1, s * dt);
          // map openCurrent (0..1) to door angles
          const maxAngle = (Math.PI / 2) * 0.9; // ~90 degrees
          gate.userData.leftPivot.rotation.y = -(
            maxAngle * gate.userData.openCurrent
          );
          gate.userData.rightPivot.rotation.y =
            maxAngle * gate.userData.openCurrent;
        }

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
